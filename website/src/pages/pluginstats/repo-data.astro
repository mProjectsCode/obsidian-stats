---
import StarlightPage from '@astrojs/starlight/components/StarlightPage.astro';
import BarChart from '../../components/svelte/charts/BarChart.svelte';
import { getPluginDataArray } from '../../utils/data';

const frontendFrameworks = ['react', 'preact', 'svelte', 'vue', '@angular/core', 'solid-js'];
const tooling = ['eslint', 'prettier', '@biomejs', 'dprint', 'typescript'];

const data = await getPluginDataArray();
const view = data.view();

const dataPoints = view.repo_data_points(data);

const frontEndFrameworksDataPoints = dataPoints.dependencies.filter(x => frontendFrameworks.includes(x.name));
const toolingDataPoints = dataPoints.dependencies.filter(x => tooling.includes(x.name));

const mostUsedDependencies = dataPoints.dependencies.filter(x => x.value >= 1);
mostUsedDependencies.sort((a, b) => b.value - a.value);

const mismatchedData = view.mismatched_data(data);
const optionalManifestFields = view.optional_manifest_fields(data);
const desktopOnlyData = view.desktop_only_data(data);
---

<StarlightPage
	frontmatter={{
		title: 'Repository Data',
		description: `Data extracted from the repositories of Plugins.`,
	}}
	headings={[
		{ depth: 2, text: 'Manifest', slug: 'manifest' },
		{ depth: 2, text: 'Dependencies', slug: 'dependencies' },
		{ depth: 3, text: 'Package Manager Usage', slug: 'package-manager-usage' },
		{ depth: 3, text: 'Code Bundler Usage', slug: 'code-bundler-usage' },
		{ depth: 3, text: 'Developer Tooling Usage', slug: 'developer-tooling-usage' },
		{ depth: 3, text: 'Testing Framework Usage', slug: 'testing-framework-usage' },
		{ depth: 3, text: 'Frontend Framework Usage', slug: 'frontend-framework-usage' },
		{ depth: 3, text: 'Most Used Dependencies', slug: 'most-used-dependencies' },
	]}
>
	<!-- <p><strong>Beta Manifest</strong>: {dataPoints.beta_manifest.toFixed(1)}% of plugins have a BRAT beta manifest.</p> -->

	<h2 id="manifest">Manifest</h2>

	<p>
		The community plugin list and the plugin manifest share some common fields, such as the <code>name</code>, <code>author</code>, and <code>description</code
		>. This can lead to mismatched data, when only one of the two sources is updated. The following chart shows the percentage of plugins that have mismatched
		data in their manifest.
	</p>

	<BarChart dataPoints={mismatchedData} xLabel="Mismatched Data" yLabel="Percent of Plugins" yDomain={[0, 100]} percentages client:visible />

	<p>
		Some fields in the manifest are optional, such as <code>authorUrl</code> and <code>fundingUrl</code>. Additionally, some plugin authors add extra,
		non-standard fields to the manifest, such as <code>helpUrl</code>. The following chart shows the percentage of plugins that have these fields set.
	</p>

	<BarChart dataPoints={optionalManifestFields} xLabel="Optional Manifest Fields" yLabel="Percent of Plugins" yDomain={[0, 100]} percentages client:visible />

	<p>Plugins can specify that they only work on the desktop version of Obsidian, which is useful for plugins that use features not available on mobile.</p>

	<BarChart dataPoints={desktopOnlyData} xLabel="Desktop Only" yLabel="Percent of Plugins" yDomain={[0, 100]} percentages client:visible />

	<h2 id="dependencies">Dependencies</h2>

	<h3 id="package-manager-usage">Package Manager Usage</h3>

	<p>
		Plugins may bundle additional dependencies into when building a release. There are several package managers that can be used to manage these dependencies,
		such as npm, yarn, and pnpm. These package managers create a lockfile in the repository, which can be used to determine which package manager was used.
	</p>

	<p>The below chart shows the distribution of package managers used in plugins.</p>

	<BarChart dataPoints={dataPoints.package_managers} xLabel="Package Managers" yLabel="Percent of Plugins" yDomain={[0, 100]} percentages client:visible />

	<p>
		{dataPoints.no_package_managers.toFixed(1)}% of plugins have no lockfile.
	</p>

	<h3 id="code-bundler-usage">Code Bundler Usage</h3>

	<p>
		The vast majority of plugins consist of more than just a single JavaScript file. Since Obsidian can only load a single JavaScript file, plugins need to
		bundle their code into a single file. This is done using a code bundler, such as Esbuild. Usually, the bundler is listed as a dependency in the plugin's <code
			>package.json</code
		> file.
	</p>

	<BarChart dataPoints={dataPoints.bundlers} xLabel="Code Bundlers" yLabel="Percent of Plugins" yDomain={[0, 100]} percentages client:visible />

	<p>
		{dataPoints.no_bundlers.toFixed(1)}% of plugins use no code bundler.
	</p>

	<h3 id="developer-tooling-usage">Developer Tooling Usage</h3>

	<p>Plugin developers like to use tooling to make their jobs easier. The chart below shows the usage percentage of common developer tooling.</p>

	<BarChart dataPoints={toolingDataPoints} xLabel="Tooling Dependencies" yLabel="Percent of Plugins" yDomain={[0, 100]} percentages client:visible />

	<h3 id="testing-framework-usage">Testing Framework Usage</h3>

	<p>
		When building a plugin, it is important to test it to ensure that it works as expected. There are several testing frameworks that can automatically test
		small parts of plugins, so called unit tests. The chart below shows the usage percentage of common testing frameworks. The data is extracted from the <code
			>package.json</code
		> file of the plugin.
	</p>

	<BarChart dataPoints={dataPoints.testing_frameworks} xLabel="Testing Frameworks" yLabel="Percent of Plugins" yDomain={[0, 100]} percentages client:visible />

	<p>
		{dataPoints.no_testing_frameworks.toFixed(1)}% of plugins use no testing framework.
	</p>

	<h3 id="frontend-framework-usage">Frontend Framework Usage</h3>

	<p>
		For complex user interfaces, plugins may use a frontend framework to make development easier. The chart below shows the usage percentage of common frontend
		frameworks. The data is extracted from the <code>package.json</code> file of the plugin.
	</p>

	<BarChart dataPoints={frontEndFrameworksDataPoints} xLabel="Frontend Frameworks" yLabel="Percent of Plugins" yDomain={[0, 100]} percentages client:visible />

	<h3 id="most-used-dependencies">Most Used Dependencies</h3>

	<p>This table shows direct dependencies of all plugins, sorted by how many plugins use them. Dependencies with less than one percent usage are not shown.</p>

	<table>
		<thead>
			<tr>
				<th> Name</th>
				<th> Usage Percentage</th>
			</tr>
		</thead>
		<tbody>
			{
				mostUsedDependencies.map(x => (
					<tr>
						<td>{x.name}</td>
						<td>{x.value.toFixed(1)}%</td>
					</tr>
				))
			}
		</tbody>
	</table>
</StarlightPage>
